/*function circleDragSetupX(draggableCircle, otherCircle, isStartCircle)
{
    let startEvent = 'mousedown';
    let moveEvent = 'mousemove';
    let endEvent = 'mouseup';
    if ('ontouchstart' in window) 
    {
        startEvent = 'touchstart';
        moveEvent = 'touchmove';
        endEvent = 'touchend';
    }
    draggableCircle.circle.addEventListener(startEvent, function(event)
    {
        event.preventDefault();
        let newPos, edge, shift;
        if (startEvent == 'touchstart') shift = (window.innerWidth * (event.touches[0].clientX / window.innerWidth)) - draggableCircle.getBounds().left;
        else shift = (window.innerWidth * (event.clientX / window.innerWidth)) - draggableCircle.getBounds().left;
        document.addEventListener(moveEvent, onMouseMove);
        document.addEventListener(endEvent, onMouseUp);
        function onMouseMove(event)
        {
            if (startEvent == 'touchstart') newPos = (window.innerWidth * (event.touches[0].clientX / window.innerWidth)) - shift - axisX.getBoundingClientRect().left;
            else newPos = (window.innerWidth * (event.clientX / window.innerWidth)) - shift - axisX.getBoundingClientRect().left;
            edge = axisX.offsetWidth - draggableCircle.getOffsetWidth();
            if (isStartCircle)
            {
                let otherCircleLeft = otherCircle.getBounds().left - axisX.getBoundingClientRect().left;
                if (newPos > otherCircleLeft - draggableCircle.getOffsetWidth()) newPos = otherCircleLeft - draggableCircle.getOffsetWidth();
            }
            else
            {
                let otherCircleLeft = otherCircle.getBounds().right - axisX.getBoundingClientRect().left;
                if (newPos < otherCircleLeft) newPos = otherCircleLeft;
            }
            if (currentGraph.currentLevel > 3)
            {
                if (newPos < -115) newPos = toInfinity(draggableCircle, "plotNegInf", "negInf");
                else if (newPos > 760) newPos = toInfinity(draggableCircle, "plotPosInf", "posInf");
                else newPos = setIntervalPosition(draggableCircle, otherCircle, newPos, isStartCircle, edge);
            }
            else newPos = setIntervalPosition(draggableCircle, otherCircle, newPos, isStartCircle, edge);
            draggableCircle.circle.style.left = newPos + 'px';
            if (isStartCircle) draggableCircle.line.style.left = newPos + currentGraph.offset + 'px';
            else draggableCircle.line.style.left = newPos + currentGraph.offset + 'px';
            updateLabelPos(draggableCircle);
            drawFilledArea(intervals[0].getBounds().left + 15, 15, intervals[1].getBounds().left - intervals[0].getBounds().left - 5, 480);
        }
        function onMouseUp() 
        {
            document.removeEventListener(endEvent, onMouseUp);
            document.removeEventListener(moveEvent, onMouseMove);
        }
    });
    draggableCircle.circle.ondragstart = function() { return false; };
}*/
/*window.onload = function()
{
    let levelName = window.sessionStorage.getItem("lygis");
    let graphNumber = window.sessionStorage.getItem("graphNumber");
    let graphAnimation = [intervalAnimations[0], intervalAnimations[1]];
    if (levelName != "empty")
    {
        for (let i = 0; i < graphs.length; i++) 
        {
            if (graphs[i].graphName == levelName)
            {
                currentGraph = graphs[i];
                document.getElementById("title").innerText = "Apibrėžimo sritis - " + levelName;
                document.getElementById("levelTag").innerText = "Apibrėžimo sritis - " + levelName;
                graphAnimation[0] = intervalAnimations[i * 2];
                graphAnimation[1] = intervalAnimations[i * 2 + 1];
                Graph.graphNumber = graphNumber;
                break;
            }
        }
    }
    else currentGraph = graphs[0];
    filledArea = document.getElementById("filledArea").getContext("2d");
    filledArea.fillStyle = "rgba(180, 180, 180, 0.4)";
    initializeNewGraph();
    setColor();
    let isInfinity1, isInfinity2;
    if (currentGraph.inputAnswer.includes("=") && currentGraph.inputAnswer.split("=")[1][2] == "∞") isInfinity1 = false;
    else isInfinity1 = currentGraph.inputAnswer[2] != "∞";
    isInfinity2 = currentGraph.inputAnswer.split(";")[1][0] != "∞";
    if (isInfinity1 && !isInfinity2) animateInterval(graphAnimation[0].index, graphAnimation[0].seconds, graphAnimation[0].end, 1, graphAnimation[1].end);
    else if (!isInfinity1 && isInfinity2) animateInterval(graphAnimation[1].index, graphAnimation[1].seconds, graphAnimation[1].end, 0, graphAnimation[0].end);
    else 
    {
        animateInterval(graphAnimation[0].index, graphAnimation[0].seconds, graphAnimation[0].end, -1, 0);
        animateInterval(graphAnimation[1].index, graphAnimation[1].seconds, graphAnimation[1].end, -1, 0);
    }
}*/